extern crate minifb;
use vm;
use minifb::{Key, Scale, WindowOptions, Window};
//this module handles rendering so you don't need to code
//tedious 'software' rendering. You can still do that if you want to, via
//writing colors to the gbuffer (RAM[5]).


pub static mut VRAM: [u32; 4096] = [0xDEADBEEF; 4096]; //ram for storing spritesheets
//vram can hold 16 different 16x16 tiles with 32bit color

pub unsafe fn initialize(win: &mut Window) {
    let test_sprite = vec![
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00
    ];
    copy_sprite(0, test_sprite);
}

pub unsafe fn copy_sprite(spritenum: u32, sprite: Vec<u32>) {
    let mut i = 0;
    for _ in spritenum * 255..(spritenum * 255)+255 {
        let tin = (spritenum * 255) + i;
        VRAM[tin as usize] = sprite[i as usize];
        i=i+1;
    }
}
