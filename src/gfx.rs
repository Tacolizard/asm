extern crate minifb;
use vm;
use minifb::{Key, Scale, WindowOptions, Window};
//this module handles rendering so you don't need to code
//tedious 'software' rendering. You can still do that if you want to, via
//writing colors to the gbuffer (RAM[5]).


pub static mut VRAM: [u32; 4096] = [0xDEADBEEF; 4096]; //ram for storing spritesheets
//vram can hold 16 different 16x16 tiles with 32bit color
//32bits for color is ridiculously large and very inefficient but it's convient
//to use for right now.

pub unsafe fn initialize() {
    let test_sprite = vec![
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00,
    0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00, 0xe5ff00
    ];
    copy_sprite(0, test_sprite);
}

pub unsafe fn update(buf: [u32; 44100]) -> [u32; 44100] {
    let mut obuf = buf;
    obuf = draw_sprite(0,vm::RAM[6],vm::RAM[6],obuf);
    //obuf = draw_sprite(1,60,60,obuf);
    return obuf;
}

pub fn coord_to_index(xi: u32, yi: u32, size: u32) -> usize {
    return (yi * size + xi) as usize;
    //this function will convert x and y coords to an index of a uniform grid
}

pub unsafe fn draw_sprite(index: usize, x: u32, y:u32, buffer: [u32; 44100]) -> [u32; 44100] {
    let mut obuf: [u32; 44100] = buffer;
    let sprin = coord_to_index(x, y, 210); //index of first point of sprite in buffer
    for l in 0..15 {
        for t in 0..15 {
            obuf[sprin+coord_to_index(l, t, 210)] = VRAM[index+coord_to_index(l,t,16)];
        }
    }

    return obuf;
}

pub unsafe fn copy_sprite(spritenum: u32, sprite: Vec<u32>) {
    let mut i = 0;
    for _ in spritenum * 255..(spritenum * 255)+255 {
        let tin = (spritenum * 255) + i;
        VRAM[tin as usize] = sprite[i as usize];
        i=i+1;
    }
}
